> 计64	嵇天颖	2016010308

### Tomasulo Simulator 实验报告

**目录**

[TOC]



---

#### 1	实验要求

​		本实验要求同学们使用 `C/C++，python，Java `等常见编程语言设计一个用户态的 `Tomasulo` 动态流水线调度算法模拟器，能够接受一种被称为 `NEL`（相关定义参见附录）的 最简单汇编语言作为输入，模拟它在特定硬件平台（相关定义参见附录）的执行情况（各类指 令的假设运行时间在附录中给出），给出任意时钟周期的指令状态，保留栈状态，寄存器结果 状态和寄存器数值等目标结果。 



#### 2	实验原理

`Tomasulo `算法以硬件⽅式实现了寄存器重命名，允许指令乱序执⾏，这是提⾼流⽔线的吞吐 率和效率的⼀种有效⽅式。该算法⾸先出现在` IBM360/91 `处理机的浮点处理部件中，后⼴泛 应⽤于现代处理器设计中。

其核心思想是：记录和检测指令相关，操作数一旦就绪就立即执行，把发生`RAW`（写后读）冲突的可能性减少到最少。通过寄存器换名来消除`WAR`（读后写）和`WAW`（写后写）冲突。

`Tomasulo`算法分为三段：`Issue` ,`Execution`, `Write Result`。如果保留站空闲(无结构冒险),控制机制发射指令并发送操作数(对寄存器进行换名)；如果两个操作数都已就绪,且有空闲的运算器，指令就准备就绪，可以执行;如果没有就绪,就观测公共数据总线等待所需结果。写回周期通过公共数据总线将结果写入到所有等待的部件;







#### 3	完成功能

##### 		3.1	功能列表

|      | 基础功能                                                     |
| ---- | ------------------------------------------------------------ |
| 1    | 能够正确接受任意`NEL`汇编语言编写的指令序列作为输入          |
| 2    | 能够正确输出每一条指令发射的时间周期**，**执行完成的时间周期**，**写回结果的时间周期 |
| 3    | 能够正确输出各时间周期的寄存器数值                           |
| 4    | 能够正确输出各时间周期保留站状态、`LoadBuffer`状态和寄存器结果状态 |
|      | **附加功能**                                                 |
| 1    | 设计美观的交互界面                                           |



##### 		3.2	功能展示

​	 下面的展示基于测试样例`test0.nel`，并采用测试用运行时间

~~~java
//测试运行时间
final int LDTime = 3, ADDTime = 3, MULTime = 4, 
					  DIVTime = 4, JUMPTime = 1;
~~~

​     

**基础功能**

   1. 能够正确接受任意`NEL`汇编语言编写的指令序列作为输入

      * 读入`test0.nel`

      * 获得命令行输出

        ~~~c
        -----------Instructions-----------
        0 LD,F1,0x2
        1 LD,F2,0x1
        2 LD,F3,0xFFFFFFFF
        3 SUB,F1,F1,F2
        4 DIV,F4,F3,F1
        5 JUMP,0x0,F1,0x2
        6 JUMP,0xFFFFFFFF,F3,0xFFFFFFFD
        7 MUL,F3,F1,F4
        ~~~

      * 该功能实现成功

   2. 能够正确输出每一条指令发射的时间周期**，**执行完成的时间周期**，**写回结果的时间周期

       * 执行25个周期后，执行结束，命令行输出如下结果

         ~~~java
         -----------------------------------------------
         0 LD 1 4 5
         1 LD 2 5 6
         2 LD 3 7 8
         3 SUB 4 9 10
         4 DIV 5 14 15
         5 JUMP 6 11 12
         6 JUMP 12 13 14
         7 MUL 20 24 25
         ~~~

      * 该功能实现成功

			  3. 能够正确输出各时间周期的寄存器数值

         * 在`Clock = 1`处输出

           ~~~java
           F0 0 F1 0 F2 0 F3 0 F4 0 F5 0 F6 0 F7 0 
           F8 0 F9 0 F10 0 F11 0 F12 0 F13 0 F14 0 F15 0 
           F16 0 F17 0 F18 0 F19 0 F20 0 F21 0 F22 0 F23 0 
           F24 0 F25 0 F26 0 F27 0 F28 0 F29 0 F30 0 F31 0 
           ~~~

        * 在`Clock = 8`处输出

          ~~~c
          F0 0 F1 0 F2 1 F3 -1 F4 0 F5 0 F6 0 F7 0 
          F8 0 F9 0 F10 0 F11 0 F12 0 F13 0 F14 0 F15 0 
          F16 0 F17 0 F18 0 F19 0 F20 0 F21 0 F22 0 F23 0 
          F24 0 F25 0 F26 0 F27 0 F28 0 F29 0 F30 0 F31 0 
          ~~~

        * 该功能实现成功

			  4. 能够正确输出各时间周期保留站状态、`LoadBuffer`状态和寄存器结果状态

        * 保留站状态

          在`Clock = 6`时获得如下命令行输出

          ~~~java
          addRs 0 SUB Qj = null Qk = null Vj =2 Vk = 1
          addRs 1 JUMP Qj = null Qk = addRS0 Vj =0 Vk = 0
          addRs 2 null Qj = null Qk = null Vj =0 Vk = 0
          addRs 3 null Qj = null Qk = null Vj =0 Vk = 0
          addRs 4 null Qj = null Qk = null Vj =0 Vk = 0
          addRs 5 null Qj = null Qk = null Vj =0 Vk = 0
          multRs 0 DIV Qj = loader0 Qk = addRS0 Vj =0 Vk = 0
          multRs 1 null Qj = null Qk = null Vj =0 Vk = 0
          multRs 2 null Qj = null Qk = null Vj =0 Vk = 0
          ~~~

        * `LoadBuffer`状态

          在`Clock = 5`时获得如下命令行输出（为了减少输出，我这里只输出`Busy`状态的`LoadBuffer`)

          ~~~java
          LoadBuffer 1 LD isBusy = true loadAddr = 1
          LoadBuffer 2 LD isBusy = true loadAddr = -1
          ~~~

        * 寄存器结果状态

          在`Clock = 5`时获得如下命令行输出（为了减少输出，只输出等待结果的寄存器）

          ~~~java
          Registers
          F1 addRS0 F2 loader1 F3 loader0 F4 multRS0 
          ~~~

        * 该功能实现完成



 **附加功能**

1  设计美观的交互界面

​	交互界面如下图所示，点击`Next`按钮可以逐步运行，可以显示出：

		* `LoadBuffer`状态
		* 保留站状态
		* 运算器状态
		* 寄存器状态和数值
		* 当前时钟指令信息（在当前周期发射的指令，第一次执行完毕的指令，第一次写回的指令）

![](.\figs\jiemian.png)























































































#### 4	实现设计思路

##### 		4.1	后端设计

###### 					4.1.1	CFG文法处理类介绍







###### 					4.1.2	模拟器算法部件类介绍

###### 					4.1.3	算法流程设计



##### 		4.2	前端设计

###### 					4.2.1	主要类介绍

###### 					4.2.2	前端函数介绍





#### 5	程序运行说明



#### 6	项目文件说明





#### 7 	运行实例

##### 		7.1	提供的三份测试

##### 		7.2	自己准备的NEL语言样例程序







